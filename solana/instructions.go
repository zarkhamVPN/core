// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package solana

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "claim_arkham_tokens" instruction.
func NewClaimArkhamTokensInstruction(
	wardenAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	arkhamMintAccount solanago.PublicKey,
	wardenArkhamTokenAccountAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 3 "arkham_mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(arkhamMintAccount, true, false))
		// Account 4 "warden_arkham_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenArkhamTokenAccountAccount, true, false))
		// Account 5 "mint_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "claim_earnings" instruction.
func NewClaimEarningsInstruction(
	// Params:
	usePrivateParam bool,

	// Accounts:
	wardenAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	solVaultAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClaimEarnings[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `usePrivateParam`:
		err = enc__.Encode(usePrivateParam)
		if err != nil {
			return nil, errors.NewField("usePrivateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "sol_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(solVaultAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "claim_unstake" instruction.
func NewClaimUnstakeInstruction(
	wardenAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	solVaultAccount solanago.PublicKey,
	usdcVaultAccount solanago.PublicKey,
	usdtVaultAccount solanago.PublicKey,
	stakeToAccountAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "sol_vault": Writable, Non-signer, Required
		// The protocol's SOL vault (PDA)
		accounts__.Append(solanago.NewAccountMeta(solVaultAccount, true, false))
		// Account 3 "usdc_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdcVaultAccount, true, false))
		// Account 4 "usdt_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdtVaultAccount, true, false))
		// Account 5 "stake_to_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stakeToAccountAccount, true, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "close_protocol_config" instruction.
func NewCloseProtocolConfigInstruction(
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	receiverAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Writable, Non-signer, Required
		// Protocol config account to close - using AccountInfo to avoid deserialization
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		// The authority that should match the one stored in the account
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "receiver": Writable, Non-signer, Required
		// Receiver of the rent (can be the authority or another account)
		accounts__.Append(solanago.NewAccountMeta(receiverAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "deposit_escrow" instruction.
func NewDepositEscrowInstruction(
	// Params:
	amountParam uint64,
	usePrivateParam bool,

	// Accounts:
	seekerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositEscrow[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `usePrivateParam`:
		err = enc__.Encode(usePrivateParam)
		if err != nil {
			return nil, errors.NewField("usePrivateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "seeker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "distribute_subsidies" instruction.
func NewDistributeSubsidiesInstruction(
	// Params:
	wardenKeysParam []solanago.PublicKey,
	subsidyAmountsParam []uint64,

	// Accounts:
	protocolConfigAccount solanago.PublicKey,
	treasuryAccount solanago.PublicKey,
	arkhamMintAccount solanago.PublicKey,
	treasuryAuthorityAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DistributeSubsidies[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `wardenKeysParam`:
		err = enc__.Encode(wardenKeysParam)
		if err != nil {
			return nil, errors.NewField("wardenKeysParam", err)
		}
		// Serialize `subsidyAmountsParam`:
		err = enc__.Encode(subsidyAmountsParam)
		if err != nil {
			return nil, errors.NewField("subsidyAmountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 1 "treasury": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(treasuryAccount, true, false))
		// Account 2 "arkham_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(arkhamMintAccount, false, false))
		// Account 3 "treasury_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(treasuryAuthorityAccount, false, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "end_connection" instruction.
func NewEndConnectionInstruction(
	connectionAccount solanago.PublicKey,
	seekerAccount solanago.PublicKey,
	wardenAccount solanago.PublicKey,
	seekerAuthorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EndConnection[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "connection": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(connectionAccount, true, false))
		// Account 1 "seeker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAccount, true, false))
		// Account 2 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 3 "seeker_authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAuthorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	dummyAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dummy_account": Read-only, Signer, Required
		// Simple initialization for testing - just log a message
		accounts__.Append(solanago.NewAccountMeta(dummyAccountAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_arkham_mint" instruction.
func NewInitializeArkhamMintInstruction(
	arkhamMintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "arkham_mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(arkhamMintAccount, true, false))
		// Account 1 "mint_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 2 "protocol_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_protocol_config" instruction.
func NewInitializeProtocolConfigInstruction(
	// Params:
	baseRatePerMbParam uint64,
	protocolFeeBpsParam uint16,
	tierThresholdsParam [3]uint64,
	tierMultipliersParam [3]uint16,
	tokensPer5gbParam uint64,
	geoPremiumsParam []GeoPremium,
	oracleAuthorityParam solanago.PublicKey,

	// Accounts:
	protocolConfigAccount solanago.PublicKey,
	treasuryAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeProtocolConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `baseRatePerMbParam`:
		err = enc__.Encode(baseRatePerMbParam)
		if err != nil {
			return nil, errors.NewField("baseRatePerMbParam", err)
		}
		// Serialize `protocolFeeBpsParam`:
		err = enc__.Encode(protocolFeeBpsParam)
		if err != nil {
			return nil, errors.NewField("protocolFeeBpsParam", err)
		}
		// Serialize `tierThresholdsParam`:
		err = enc__.Encode(tierThresholdsParam)
		if err != nil {
			return nil, errors.NewField("tierThresholdsParam", err)
		}
		// Serialize `tierMultipliersParam`:
		err = enc__.Encode(tierMultipliersParam)
		if err != nil {
			return nil, errors.NewField("tierMultipliersParam", err)
		}
		// Serialize `tokensPer5gbParam`:
		err = enc__.Encode(tokensPer5gbParam)
		if err != nil {
			return nil, errors.NewField("tokensPer5gbParam", err)
		}
		// Serialize `geoPremiumsParam`:
		err = enc__.Encode(geoPremiumsParam)
		if err != nil {
			return nil, errors.NewField("geoPremiumsParam", err)
		}
		// Serialize `oracleAuthorityParam`:
		err = enc__.Encode(oracleAuthorityParam)
		if err != nil {
			return nil, errors.NewField("oracleAuthorityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, true, false))
		// Account 1 "treasury": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(treasuryAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_warden" instruction.
func NewInitializeWardenInstruction(
	// Params:
	stakeTokenParam StakeToken,
	stakeAmountParam uint64,
	peerIdParam string,
	regionCodeParam uint8,
	ipHashParam [32]uint8,
	priceParam uint64,
	timestampParam int64,
	signatureParam [64]uint8,

	// Accounts:
	wardenAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	stakeFromAccountAccount solanago.PublicKey,
	solVaultAccount solanago.PublicKey,
	usdcVaultAccount solanago.PublicKey,
	usdtVaultAccount solanago.PublicKey,
	usdcMintAccount solanago.PublicKey,
	usdtMintAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeWarden[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `stakeTokenParam`:
		err = enc__.Encode(stakeTokenParam)
		if err != nil {
			return nil, errors.NewField("stakeTokenParam", err)
		}
		// Serialize `stakeAmountParam`:
		err = enc__.Encode(stakeAmountParam)
		if err != nil {
			return nil, errors.NewField("stakeAmountParam", err)
		}
		// Serialize `peerIdParam`:
		err = enc__.Encode(peerIdParam)
		if err != nil {
			return nil, errors.NewField("peerIdParam", err)
		}
		// Serialize `regionCodeParam`:
		err = enc__.Encode(regionCodeParam)
		if err != nil {
			return nil, errors.NewField("regionCodeParam", err)
		}
		// Serialize `ipHashParam`:
		err = enc__.Encode(ipHashParam)
		if err != nil {
			return nil, errors.NewField("ipHashParam", err)
		}
		// Serialize `priceParam`:
		err = enc__.Encode(priceParam)
		if err != nil {
			return nil, errors.NewField("priceParam", err)
		}
		// Serialize `timestampParam`:
		err = enc__.Encode(timestampParam)
		if err != nil {
			return nil, errors.NewField("timestampParam", err)
		}
		// Serialize `signatureParam`:
		err = enc__.Encode(signatureParam)
		if err != nil {
			return nil, errors.NewField("signatureParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 4 "stake_from_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stakeFromAccountAccount, true, false))
		// Account 5 "sol_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(solVaultAccount, true, false))
		// Account 6 "usdc_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdcVaultAccount, true, false))
		// Account 7 "usdt_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdtVaultAccount, true, false))
		// Account 8 "usdc_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdcMintAccount, false, false))
		// Account 9 "usdt_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usdtMintAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 12 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "migrate_protocol_config" instruction.
func NewMigrateProtocolConfigInstruction(
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	newOracleAuthorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "new_oracle_authority": Read-only, Non-signer, Required
		// New oracle authority to set
		accounts__.Append(solanago.NewAccountMeta(newOracleAuthorityAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "start_connection" instruction.
func NewStartConnectionInstruction(
	// Params:
	estimatedMbParam uint64,

	// Accounts:
	connectionAccount solanago.PublicKey,
	seekerAccount solanago.PublicKey,
	wardenAccount solanago.PublicKey,
	seekerAuthorityAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_StartConnection[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `estimatedMbParam`:
		err = enc__.Encode(estimatedMbParam)
		if err != nil {
			return nil, errors.NewField("estimatedMbParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "connection": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(connectionAccount, true, false))
		// Account 1 "seeker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAccount, true, false))
		// Account 2 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 3 "seeker_authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAuthorityAccount, true, true))
		// Account 4 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "submit_bandwidth_proof" instruction.
func NewSubmitBandwidthProofInstruction(
	// Params:
	mbConsumedParam uint64,
	timestampParam int64,
	seekerSignatureParam [64]uint8,
	wardenSignatureParam [64]uint8,

	// Accounts:
	connectionAccount solanago.PublicKey,
	wardenAccount solanago.PublicKey,
	seekerAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	submitterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SubmitBandwidthProof[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mbConsumedParam`:
		err = enc__.Encode(mbConsumedParam)
		if err != nil {
			return nil, errors.NewField("mbConsumedParam", err)
		}
		// Serialize `timestampParam`:
		err = enc__.Encode(timestampParam)
		if err != nil {
			return nil, errors.NewField("timestampParam", err)
		}
		// Serialize `seekerSignatureParam`:
		err = enc__.Encode(seekerSignatureParam)
		if err != nil {
			return nil, errors.NewField("seekerSignatureParam", err)
		}
		// Serialize `wardenSignatureParam`:
		err = enc__.Encode(wardenSignatureParam)
		if err != nil {
			return nil, errors.NewField("wardenSignatureParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "connection": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(connectionAccount, true, false))
		// Account 1 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 2 "seeker": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(seekerAccount, true, false))
		// Account 3 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 4 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 5 "submitter": Read-only, Signer, Required
		// Either seeker or warden can submit proofs
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unstake_warden" instruction.
func NewUnstakeWardenInstruction(
	wardenAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_premium_pool_rankings" instruction.
func NewUpdatePremiumPoolRankingsInstruction(
	// Params:
	topWardensParam []solanago.PublicKey,

	// Accounts:
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePremiumPoolRankings[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `topWardensParam`:
		err = enc__.Encode(topWardensParam)
		if err != nil {
			return nil, errors.NewField("topWardensParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_protocol_config" instruction.
func NewUpdateProtocolConfigInstruction(
	// Params:
	newBaseRatePerMbParam *uint64,
	newProtocolFeeBpsParam *uint16,
	newTierThresholdsParam *[3]uint64,
	newTierMultipliersParam *[3]uint16,
	newTokensPer5gbParam *uint64,
	newGeoPremiumsParam *[]GeoPremium,
	newReputationUpdaterParam *solanago.PublicKey,
	newOracleAuthorityParam *solanago.PublicKey,

	// Accounts:
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateProtocolConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newBaseRatePerMbParam` (optional):
		{
			if newBaseRatePerMbParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newBaseRatePerMbParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newBaseRatePerMbParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newBaseRatePerMbParam)
				if err != nil {
					return nil, errors.NewField("newBaseRatePerMbParam", err)
				}
			}
		}
		// Serialize `newProtocolFeeBpsParam` (optional):
		{
			if newProtocolFeeBpsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newProtocolFeeBpsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newProtocolFeeBpsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newProtocolFeeBpsParam)
				if err != nil {
					return nil, errors.NewField("newProtocolFeeBpsParam", err)
				}
			}
		}
		// Serialize `newTierThresholdsParam` (optional):
		{
			if newTierThresholdsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newTierThresholdsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newTierThresholdsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newTierThresholdsParam)
				if err != nil {
					return nil, errors.NewField("newTierThresholdsParam", err)
				}
			}
		}
		// Serialize `newTierMultipliersParam` (optional):
		{
			if newTierMultipliersParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newTierMultipliersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newTierMultipliersParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newTierMultipliersParam)
				if err != nil {
					return nil, errors.NewField("newTierMultipliersParam", err)
				}
			}
		}
		// Serialize `newTokensPer5gbParam` (optional):
		{
			if newTokensPer5gbParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newTokensPer5gbParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newTokensPer5gbParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newTokensPer5gbParam)
				if err != nil {
					return nil, errors.NewField("newTokensPer5gbParam", err)
				}
			}
		}
		// Serialize `newGeoPremiumsParam` (optional):
		{
			if newGeoPremiumsParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newGeoPremiumsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newGeoPremiumsParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newGeoPremiumsParam)
				if err != nil {
					return nil, errors.NewField("newGeoPremiumsParam", err)
				}
			}
		}
		// Serialize `newReputationUpdaterParam` (optional):
		{
			if newReputationUpdaterParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newReputationUpdaterParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newReputationUpdaterParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newReputationUpdaterParam)
				if err != nil {
					return nil, errors.NewField("newReputationUpdaterParam", err)
				}
			}
		}
		// Serialize `newOracleAuthorityParam` (optional):
		{
			if newOracleAuthorityParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("newOracleAuthorityParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("newOracleAuthorityParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(newOracleAuthorityParam)
				if err != nil {
					return nil, errors.NewField("newOracleAuthorityParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reputation" instruction.
func NewUpdateReputationInstruction(
	// Params:
	connectionSuccessParam bool,
	uptimeReportParam uint16,

	// Accounts:
	wardenAccount solanago.PublicKey,
	protocolConfigAccount solanago.PublicKey,
	wardenAuthorityAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateReputation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `connectionSuccessParam`:
		err = enc__.Encode(connectionSuccessParam)
		if err != nil {
			return nil, errors.NewField("connectionSuccessParam", err)
		}
		// Serialize `uptimeReportParam`:
		err = enc__.Encode(uptimeReportParam)
		if err != nil {
			return nil, errors.NewField("uptimeReportParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "warden": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
		// Account 1 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 2 "warden_authority": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wardenAuthorityAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_warden_peer_id" instruction.
func NewUpdateWardenPeerIdInstruction(
	// Params:
	newPeerIdParam string,

	// Accounts:
	protocolConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	wardenAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateWardenPeerId[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newPeerIdParam`:
		err = enc__.Encode(newPeerIdParam)
		if err != nil {
			return nil, errors.NewField("newPeerIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "protocol_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolConfigAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		// The protocol authority must sign to authorize this change.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "warden": Writable, Non-signer, Required
		// The warden account to be updated.
		accounts__.Append(solanago.NewAccountMeta(wardenAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
